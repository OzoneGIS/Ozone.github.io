{"version":3,"file":"audit-trail.js","sourceRoot":"","sources":["../../../../../src/database/list/audit-trail.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAG/C,OAAO,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAGhD,OAAO,6BAA6B,CAAC;AACrC,OAAO,kCAAkC,CAAC;AAC1C,OAAO,uBAAuB,CAAC;AAE/B,MAAM,2BAA2B,KAAoB;IACnD,MAAM,CAAC,CAAC,MAAqB,KAAK,UAAU,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;CAC7D;AAED,MAAM,qBAAqB,KAAoB,EAAE,MAAqB;IACpE,MAAM,WAAW,GAAG,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC;SAC5C,IAAI,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK,CAAC,GAAG,OAAO,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;IACvD,MAAM,CAAC,aAAa,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;CAC1C;AAOD,oBAAoB,KAAoB;IAItC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC;SAC7B,GAAG,CAAC,IAAI;QAEP,IAAI,aAAa,CAAC;QAElB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK;YACxB,aAAa,GAAG,KAAK,CAAC,GAAG,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;SACzC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,IAAI,EAAE,aAAa,EAAE,CAAC;KAChC,CAAC,CAAC;CACJ;AAED,uBAAuB,KAAoB,EAAE,OAAqC;IAChF,MAAM,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;IAClC,MAAM,CAAC,OAAO;SACX,cAAc,CAAC,OAAO,CAAC;SAGvB,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC;QAErB,IAAI,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;QAEzC,MAAM,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QACjD,MAAM,CAAC,EAAE,OAAO,EAAE,aAAa,EAAE,UAAU,EAAE,CAAA;KAC9C,CAAC;SAID,SAAS,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC;SAGrE,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC;CAC9B","sourcesContent":["import { DatabaseQuery, ChildEvent, DatabaseSnapshot, AngularFireAction, SnapshotAction } from '../interfaces';\nimport { stateChanges } from './state-changes';\nimport { Observable } from 'rxjs/Observable';\nimport { DataSnapshot } from '@firebase/database-types';\nimport { fromRef } from '../observable/fromRef';\n\n\nimport 'rxjs/add/operator/skipWhile';\nimport 'rxjs/add/operator/withLatestFrom';\nimport 'rxjs/add/operator/map';\n\nexport function createAuditTrail(query: DatabaseQuery) {\n  return (events?: ChildEvent[]) => auditTrail(query, events);\n}\n\nexport function auditTrail(query: DatabaseQuery, events?: ChildEvent[]): Observable<SnapshotAction[]> {\n  const auditTrail$ = stateChanges(query, events)\n    .scan((current, action) => [...current, action], []);\n  return waitForLoaded(query, auditTrail$);\n}\n\ninterface LoadedMetadata {\n  data: AngularFireAction<DataSnapshot>;\n  lastKeyToLoad: any;\n}\n\nfunction loadedData(query: DatabaseQuery): Observable<LoadedMetadata> {\n  // Create an observable of loaded values to retrieve the\n  // known dataset. This will allow us to know what key to\n  // emit the \"whole\" array at when listening for child events.\n  return fromRef(query, 'value')\n  .map(data => {\n    // Store the last key in the data set\n    let lastKeyToLoad;\n    // Loop through loaded dataset to find the last key\n    data.payload.forEach(child => {\n      lastKeyToLoad = child.key; return false;\n    });\n    // return data set and the current last key loaded\n    return { data, lastKeyToLoad };\n  });\n}\n\nfunction waitForLoaded(query: DatabaseQuery, action$: Observable<SnapshotAction[]>) {\n  const loaded$ = loadedData(query);\n  return loaded$\n    .withLatestFrom(action$)\n    // Get the latest values from the \"loaded\" and \"child\" datasets\n    // We can use both datasets to form an array of the latest values.\n    .map(([loaded, actions]) => {\n      // Store the last key in the data set\n      let lastKeyToLoad = loaded.lastKeyToLoad;\n      // Store all child keys loaded at this point\n      const loadedKeys = actions.map(snap => snap.key);\n      return { actions, lastKeyToLoad, loadedKeys }\n    })\n    // This is the magical part, only emit when the last load key\n    // in the dataset has been loaded by a child event. At this point\n    // we can assume the dataset is \"whole\".\n    .skipWhile(meta => meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1)\n    // Pluck off the meta data because the user only cares\n    // to iterate through the snapshots\n    .map(meta => meta.actions);\n}\n"]}